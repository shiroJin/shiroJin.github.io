<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">
<meta name="referrer" content="no-referrer">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.12.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="知其然知其所以然！">
<meta property="og:type" content="website">
<meta property="og:title" content="一只代码狗的随笔">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="一只代码狗的随笔">
<meta property="og:description" content="知其然知其所以然！">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jin.">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>一只代码狗的随笔</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">一只代码狗的随笔</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">知其然知其所以然！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jin.</p>
  <div class="site-description" itemprop="description">知其然知其所以然！</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/20/UML%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jin.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只代码狗的随笔">
      <meta itemprop="description" content="知其然知其所以然！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 一只代码狗的随笔">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/20/UML%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/" class="post-title-link" itemprop="url">UML基础用法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-06-20 16:48:26" itemprop="dateCreated datePublished" datetime="2022-06-20T16:48:26+08:00">2022-06-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-07-02 16:06:12" itemprop="dateModified" datetime="2022-07-02T16:06:12+08:00">2022-07-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="UML基础用法"><a href="#UML基础用法" class="headerlink" title="UML基础用法"></a>UML基础用法</h1><h2 id="类关系"><a href="#类关系" class="headerlink" title="类关系"></a>类关系</h2><ol>
<li>泛化（Generalization）<br>表现为继承</li>
<li>实现（Realization）<br>表现为实现接口</li>
<li>关联（Association）<br>表现为成员变量，一种强依赖的关系</li>
<li>聚合（Aggregation）<br>一种强关联，关联关系双方是平级的，是个体和个体的关系，聚合关系双方不是平级的，是整体和部分的关系。</li>
<li>组合（Compostion）<br>组合关系是一种强聚合的关系，组合关系与聚合关系的区别在于：聚合关系中部分离开整体仍可存活，组合关系中部分离开整体没有意义</li>
<li>依赖（Dependency）<br>一种使用关系，依赖方可以是参数，也可以是返回值。</li>
</ol>
<p>各种关系的强弱顺序：泛化 &#x3D; 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖</p>
<h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><h3 id="Defining-Relationship"><a href="#Defining-Relationship" class="headerlink" title="Defining Relationship"></a>Defining Relationship</h3><p>对应的是上述类之间的关系，UML中区分的很细致。</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;|–</td>
<td>Inheritance</td>
</tr>
<tr>
<td>*–</td>
<td>Composition</td>
</tr>
<tr>
<td>o–</td>
<td>Aggregation</td>
</tr>
<tr>
<td>–&gt;</td>
<td>Association</td>
</tr>
<tr>
<td>–</td>
<td>Link (Solid)</td>
</tr>
<tr>
<td>..&gt;</td>
<td>Dependency</td>
</tr>
<tr>
<td>..|&gt;</td>
<td>Realization</td>
</tr>
<tr>
<td>..</td>
<td>Link (Dashed)</td>
</tr>
</tbody></table>
<img src="https://raw.githubusercontent.com/shiroJin/image-storage/master/UML_class_relation.png">

<h3 id="Defining-a-class"><a href="#Defining-a-class" class="headerlink" title="Defining a class"></a>Defining a class</h3><p>UML中使用框形式表示一个类。如下：</p>
<img src="https://raw.githubusercontent.com/shiroJin/image-storage/master/UML_example1.png">

<ul>
<li><p>第一格表示类&#x2F;接口名称<br>名称，声明的是接口则标注关键字*&lt;<interface>&gt;<em>, 抽象类标注</em>&lt;<abstract>&gt;*，枚举类型&lt;<enumeration>&gt;，service class&lt;<service>&gt;</p>
</li>
<li><p>第二格表示声明的成员变量<br>第一个字符表示属性，例如公开，私有。随后是成员类型，最后是名称</p>
</li>
<li><p>第三格表示声明的方法<br>方法和成员相似，不同的是有个括号，括号内是参数名称。成员类型字段表示returnType。当没有返回值时returntype可以省略。</p>
</li>
</ul>
<h3 id="Defining-member-of-a-class"><a href="#Defining-member-of-a-class" class="headerlink" title="Defining member of a class"></a>Defining member of a class</h3><table>
<thead>
<tr>
<th>Type</th>
<th>Examples</th>
<th>keyword</th>
</tr>
</thead>
<tbody><tr>
<td>Public</td>
<td>+String owner<br />+String foo()</td>
<td>+</td>
</tr>
<tr>
<td>Private</td>
<td>-String owner<br />-String foo()</td>
<td>-</td>
</tr>
<tr>
<td>Protect</td>
<td>#String owner<br />#foo()</td>
<td>#</td>
</tr>
<tr>
<td>Package&#x2F;internal</td>
<td><del>String owner<br /></del>foo()</td>
<td>~</td>
</tr>
<tr>
<td>Static</td>
<td><u>+String owner</u><br /><u>+foo()</u></td>
<td>underline（下划线）</td>
</tr>
<tr>
<td>Abstract</td>
<td><em>+foo()</em></td>
<td>italic（斜体）</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/13/LearnOpenGL%E5%B0%8F%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jin.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只代码狗的随笔">
      <meta itemprop="description" content="知其然知其所以然！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 一只代码狗的随笔">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/13/LearnOpenGL%E5%B0%8F%E7%BB%93/" class="post-title-link" itemprop="url">LearnOpenGL笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-06-13 23:20:58" itemprop="dateCreated datePublished" datetime="2022-06-13T23:20:58+08:00">2022-06-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-06-15 16:28:19" itemprop="dateModified" datetime="2022-06-15T16:28:19+08:00">2022-06-15</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="LearnOpenGL笔记"><a href="#LearnOpenGL笔记" class="headerlink" title="LearnOpenGL笔记"></a>LearnOpenGL笔记</h1><p>本文仅为学习OpenGL过程中的学习笔记，OpenGL细节参考<a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/%E3%80%82">https://learnopengl-cn.github.io/。</a></p>
<h2 id="OpenGL流水线"><a href="#OpenGL流水线" class="headerlink" title="OpenGL流水线"></a>OpenGL流水线</h2><p>​    在gl中坐标系是3D的，但是窗口却是2D像素数组，这导致gl大部分工作都是关于把3D坐标转变为适应屏幕的2D像素。3D坐标转为2D坐标的处理过程是由OpenGL的图形渲染管线（Graphics Pipeline，大多译为管线，指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的。图形渲染管线可以被划分为两个主要部分：第一部分把你的3D坐标转换为2D坐标（几何阶段）；第二部分是把2D坐标转变为实际的有颜色的像素(光栅化阶段)。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24721415-4fa1d9bcbfa24ff1.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt="img"></p>
<h2 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a><strong>着色器</strong></h2><p>着色器(Shader)是运行在GPU上的小程序。这些小程序为图形渲染管线的某个特定部分而运行。从基本意义上来说，着色器只是一种把输入转化为输出的程序。着色器也是一种非常独立的程序，因为它们之间不能相互通信；它们之间唯一的沟通只有通过输入和输出。着色器程序是由GLSL语言编写，openGL会编译成具体的着色程序。常规的着色器有以下几种。顶点和片段着色器是最常用的着色器程序。</p>
<ul>
<li><p>顶点着色器</p>
</li>
<li><p>几何着色器</p>
</li>
<li><p>片段着色器</p>
</li>
</ul>
<h3 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h3><p>顶点着色器作为顶点数据的入口，顶点数据一般包含位置坐标（xyz轴），纹理坐标，法向量（normal），tangent（切线），副切线（bitangent）。</p>
<p>顶点着色器应该接收的是一种特殊形式的输入。client会通过openGL来声明好顶点数据的结构，顶点着色器程序就可以访问到相应偏移量的数据，顶点着色器作为第一个着色器，将处理好的数据传递传递给下一个着色器。关键字<code>in</code>，<code> out</code>描述着色器的输入输出。</p>
<h3 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h3><p>片段着色器需要生成一个最终输出的颜色。如果你在片段着色器没有定义输出颜色，OpenGL会把你的物体渲染为黑色（或白色）。片段着色器的主要作用就是描述片段的颜色（可以理解为像素点）。实际使用过程中会配合纹理使用，同时也会涉及到光学模型，让渲染的结果更逼真。</p>
<p>片段着色器的输入由上一个着色器提供，一般为顶点着色器。</p>
<h3 id="几何着色器"><a href="#几何着色器" class="headerlink" title="几何着色器"></a>几何着色器</h3><p>几何着色器处理的是图元。比如说渲染的方式是三角形，则输入的是3个顶点数据。几何着色器可以在顶点发送到下一着色器阶段之前对它们随意变换。然而，几何着色器最有趣的地方在于，它能够将（这一组）顶点变换为完全不同的图元，并且还能生成比原来更多的顶点。</p>
<p>几何着色器可以实现法向量可视化，毛发等细节效果。</p>
<h2 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h2><p>diffuse，specular，normal，depth</p>
<p>纹理是一个2D图片（甚至也有1D和3D的纹理），它可以用来添加物体的细节；你可以想象纹理是一张绘有砖块的纸，无缝折叠贴合到你的3D的房子上，这样你的房子看起来就像有砖墙外表了。因为我们可以在一张图片上插入非常多的细节，<u>这样就可以让物体非常精细而不用指定额外的顶点</u>。</p>
<p>使用纹理坐标获取纹理颜色叫做<strong>采样</strong>，纹理坐标[0, 1]。</p>
<p>纹理的资源叫做贴图，其实就是图片。常规的贴图有以下几种：</p>
<ul>
<li>漫反射贴图</li>
<li>镜面光贴图</li>
<li>法线贴图</li>
<li>视差贴图</li>
<li>放射光贴图</li>
</ul>
<p>具体细节在光照模型中会具体描述，物理的颜色主要取决于反射或射入我们眼睛中颜色决定。</p>
<p><strong>切线空间</strong></p>
<p>在一个不同的坐标空间中进行光照，这个坐标空间里，法线贴图向量总是指向这个坐标空间的正z方向；所有的光照向量都相对与这个正z方向进行变换。这样我们就能始终使用同样的法线贴图，不管朝向问题。这个坐标空间叫做切线空间（tangent space）。</p>
<p>法线贴图中的法线向量定义在切线空间中，在切线空间中，法线永远指着正z方向。切线空间是位于三角形表面之上的空间：法线相对于单个三角形的本地参考框架。它就像法线贴图向量的本地空间；它们都被定义为指向正z方向，无论最终变换到什么方向。使用一个特定的矩阵我们就能将本地&#x2F;切线空间中的法线向量转成世界或视图空间下，使它们转向到最终的贴图表面的方向。</p>
<p>使用法线贴图也是一种提升你的场景的表现的重要方式。在使用法线贴图之前你不得不使用相当多的顶点才能表现出一个更精细的网格，但使用了法线贴图我们可以使用更少的顶点表现出同样丰富的细节。</p>
<h2 id="坐标系统"><a href="#坐标系统" class="headerlink" title="坐标系统"></a>坐标系统</h2><p>标准化设备坐标(Normalized Device Coordinate, NDC)。也就是说，每个顶点的<strong>x</strong>，<strong>y</strong>，<strong>z</strong>坐标都应该在**-1.0<strong>到</strong>1.0**之间，超出这个坐标范围的顶点都将不可见。我们通常会自己设定一个坐标的范围，之后再在顶点着色器中将这些坐标变换为标准化设备坐标。然后将这些标准化设备坐标传入光栅器(Rasterizer)，将它们变换为屏幕上的二维坐标或像素。</p>
<p>将坐标变换为标准化设备坐标，接着再转化为屏幕坐标的过程通常是分步进行的，也就是类似于流水线那样子。在流水线中，物体的顶点在最终转化为屏幕坐标之前还会被变换到多个坐标系统(Coordinate System)。将物体的坐标变换到几个<strong>过渡</strong>坐标系(Intermediate Coordinate System)的优点在于，在这些特定的坐标系统中，一些操作或运算更加方便和容易，这一点很快就会变得很明显。对我们来说比较重要的总共有5个不同的坐标系统：</p>
<ul>
<li>局部空间(Local Space，或者称为物体空间(Object Space))</li>
<li>世界空间(World Space)</li>
<li>观察空间(View Space，或者称为视觉空间(Eye Space))</li>
<li>裁剪空间(Clip Space)</li>
<li>屏幕空间(Screen Space)</li>
</ul>
<p>为了将坐标从一个坐标系变换到另一个坐标系，我们需要用到几个变换矩阵，最重要的几个分别是模型(Model)、观察(View)、投影(Projection)三个矩阵。有了上述3个变化矩阵，就可以实现旋转，平移等效果。</p>
<h2 id="光照模型"><a href="#光照模型" class="headerlink" title="光照模型"></a>光照模型</h2><p>冯氏光照模型(Phong Lighting Model)。冯氏光照模型的主要结构由3个分量组成：环境(Ambient)、漫反射(Diffuse)和镜面(Specular)光照。物体的颜色则为3个分量的向量和。</p>
<ul>
<li>环境光照(Ambient Lighting)：即使在黑暗的情况下，世界上通常也仍然有一些光亮（月亮、远处的光），所以物体几乎永远不会是完全黑暗的。为了模拟这个，我们会使用一个环境光照常量，它永远会给物体一些颜色。</li>
<li>漫反射光照(Diffuse Lighting)：模拟光源对物体的方向性影响(Directional Impact)。它是冯氏光照模型中视觉上最显著的分量。物体的某一部分越是正对着光源，它就会越亮。</li>
<li>镜面光照(Specular Lighting)：模拟有光泽物体上面出现的亮点。镜面光照的颜色相比于物体的颜色会更倾向于光的颜色。</li>
</ul>
<p>漫反射和镜面光照都和片段表面的法向量和光线向量的夹角相关，需要通过计算获得具体的计算因子。</p>
<p>除冯氏光照模型外，在冯氏模型的拓展还有<em>Blinn-Phong</em>着色模型，引入了半程向量概念，在镜面反射分量上有一个更好的表现。</p>
<h2 id="3D模型数据"><a href="#3D模型数据" class="headerlink" title="3D模型数据"></a>3D模型数据</h2><p>3D文件通常包括网格模型、UV纹理、材质贴图。常见的3D模型格式有如下几种</p>
<ul>
<li>OBJ，适用于3D软件模型之间的互导，主要支持多边形模型。</li>
<li>DAE，纯文本的模型格式，其本质是一个xml文件，可以实现动态模型。</li>
<li>FBX，最好的互导方案</li>
<li>STL，文件格式简单， 应用非常广泛</li>
</ul>
<p>一个非常流行的模型导入库是<a target="_blank" rel="noopener" href="http://assimp.org/">Assimp</a>。当使用Assimp导入一个模型的时候，它通常会将整个模型加载进一个<strong>场景</strong>(Scene)对象，它会包含导入的模型&#x2F;场景中的所有数据。Assimp会将场景载入为一系列的节点(Node)，每个节点包含了场景对象中所储存数据的索引，每个节点都可以有任意数量的子节点。Assimp数据结构的（简化）模型如下：</p>
<p><img src="https://learnopengl-cn.github.io/img/03/01/assimp_structure.png" alt="img"></p>
<ul>
<li>和材质和网格(Mesh)一样，所有的场景&#x2F;模型数据都包含在Scene对象中。Scene对象也包含了场景根节点的引用。</li>
<li>场景的Root node（根节点）可能包含子节点（和其它的节点一样），它会有一系列指向场景对象中mMeshes数组中储存的网格数据的索引。Scene下的mMeshes数组储存了真正的Mesh对象，节点中的mMeshes数组保存的只是场景中网格数组的索引。</li>
<li>一个Mesh对象本身包含了渲染所需要的所有相关数据，像是顶点位置、法向量、纹理坐标、面(Face)和物体的材质。</li>
<li>一个网格包含了多个面。Face代表的是物体的渲染图元(Primitive)（三角形、方形、点）。一个面包含了组成图元的顶点的索引。由于顶点和索引是分开的，使用一个索引缓冲来渲染是非常简单的（见[你好，三角形](<a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/01">https://learnopengl-cn.github.io/01</a> Getting started&#x2F;04 Hello Triangle&#x2F;)）。</li>
<li>最后，一个网格也包含了一个Material对象，它包含了一些函数能让我们获取物体的材质属性，比如说颜色和纹理贴图（比如漫反射和镜面光贴图）。</li>
</ul>
<h2 id="学习网站"><a href="#学习网站" class="headerlink" title="学习网站"></a>学习网站</h2><p><a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/">https://learnopengl-cn.github.io/</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/22/ARM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jin.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只代码狗的随笔">
      <meta itemprop="description" content="知其然知其所以然！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 一只代码狗的随笔">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/22/ARM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">ARM学习笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-05-22 16:56:21" itemprop="dateCreated datePublished" datetime="2022-05-22T16:56:21+08:00">2022-05-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-05-23 13:58:19" itemprop="dateModified" datetime="2022-05-23T13:58:19+08:00">2022-05-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="ARM学习笔记"><a href="#ARM学习笔记" class="headerlink" title="ARM学习笔记"></a>ARM学习笔记</h1><p>在xcode中，选中文件后<code>Product-&gt;Perform Action-&gt;Assemble xxx.m</code>就能看到汇编代码，可以更好的了解代码的执行过程。这里简单介绍下常用的一些命令（instruction）。</p>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><table>
<thead>
<tr>
<th>x0-x30</th>
<th>64bit</th>
<th>通用寄存器，如果有需要可以当做32bit使用：WO-W30</th>
</tr>
</thead>
<tbody><tr>
<td>FP(x29)</td>
<td>64bit</td>
<td>保存栈帧地址(栈底指针)。栈基址。函数调用的时候的起始栈地址</td>
</tr>
<tr>
<td>LR(x30)</td>
<td>64bit</td>
<td>通常称X30为程序链接寄存器，保存子程序结束后需要执行的下一条指令（上一次函数调用的下一条指令地址），即返回地址。</td>
</tr>
<tr>
<td>SP</td>
<td>64bit</td>
<td>保存栈指针,使用 SP&#x2F;WSP来进行对SP寄存器的访问。</td>
</tr>
<tr>
<td>PC</td>
<td>64bit</td>
<td>程序计数器，俗称PC指针，总是指向即将要执行的下一条指令,在arm64中，软件是不能改写PC寄存器的。</td>
</tr>
<tr>
<td>CPSR</td>
<td>64bit</td>
<td>状态寄存器</td>
</tr>
</tbody></table>
<p><strong>状态寄存器条件码</strong></p>
<table>
<thead>
<tr>
<th>操作码</th>
<th>条件码助记符</th>
<th>标志</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>0000</td>
<td>EQ</td>
<td>Z&#x3D;1</td>
<td>相等</td>
</tr>
<tr>
<td>0001</td>
<td>NE(Not Equal)</td>
<td>Z&#x3D;0</td>
<td>不相等</td>
</tr>
<tr>
<td>0010</td>
<td>CS&#x2F;HS(Carry Set&#x2F;High or Same)</td>
<td>C&#x3D;1</td>
<td>无符号数大于或等于</td>
</tr>
<tr>
<td>0011</td>
<td>CC&#x2F;LO(Carry Clear&#x2F;LOwer)</td>
<td>C&#x3D;0</td>
<td>无符号数小于</td>
</tr>
<tr>
<td>0100</td>
<td>MI(MInus)</td>
<td>N&#x3D;1</td>
<td>负数</td>
</tr>
<tr>
<td>0101</td>
<td>PL(PLus)</td>
<td>N&#x3D;0</td>
<td>正数或零</td>
</tr>
<tr>
<td>0110</td>
<td>VS(oVerflow set)</td>
<td>V&#x3D;1</td>
<td>溢出</td>
</tr>
<tr>
<td>0111</td>
<td>VC(oVerflow clear)</td>
<td>V&#x3D;0</td>
<td>没有溢出</td>
</tr>
<tr>
<td>1000</td>
<td>HI(High)</td>
<td>C&#x3D;1,Z&#x3D;0</td>
<td>无符号数大于</td>
</tr>
<tr>
<td>1001</td>
<td>LS(Lower or Same)</td>
<td>C&#x3D;0,Z&#x3D;1</td>
<td>无符号数小于或等于</td>
</tr>
<tr>
<td>1010</td>
<td>GE(Greater or Equal)</td>
<td>N&#x3D;V</td>
<td>有符号数大于或等于</td>
</tr>
<tr>
<td>1011</td>
<td>LT(Less Than)</td>
<td>N!&#x3D;V</td>
<td>有符号数小于</td>
</tr>
<tr>
<td>1100</td>
<td>GT(Greater Than)</td>
<td>Z&#x3D;0,N&#x3D;V</td>
<td>有符号数大于</td>
</tr>
<tr>
<td>1101</td>
<td>LE(Less or Equal)</td>
<td>Z&#x3D;1,N!&#x3D;V</td>
<td>有符号数小于或等于</td>
</tr>
<tr>
<td>1110</td>
<td>AL</td>
<td>任何</td>
<td>无条件执行(默认)</td>
</tr>
<tr>
<td>1111</td>
<td>NV</td>
<td>任何</td>
<td>从不执行</td>
</tr>
</tbody></table>
<h2 id="指令与伪指令"><a href="#指令与伪指令" class="headerlink" title="指令与伪指令"></a>指令与伪指令</h2><p>指令有对应的机器码，CPU可以直接识别并执行。而伪指令，没有对应的机器码，它需要经过编译器翻译成指令才能被CPU识别和执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ldr r1, =0xfff //伪指令</span><br><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">@这是一条伪指令，没有对应的机器码，被编译器翻译为LDR       R0,[PC,#0x0008]</span><br><span class="line">LDR R0, =var ; int * R0 = var</span><br><span class="line">@这是一条指令</span><br><span class="line">LDR R1, [R0] ; int R1 = *R0</span><br><span class="line">@指令有对应的机器码，编译器原样执行</span><br><span class="line">MOV R1, R0</span><br><span class="line">NOP</span><br><span class="line">NOP</span><br><span class="line">.data</span><br><span class="line">var: int * var; *var = 0x8;</span><br><span class="line">.word 0x8</span><br><span class="line">.end</span><br></pre></td></tr></table></figure>



<h2 id="常见指令"><a href="#常见指令" class="headerlink" title="常见指令"></a>常见指令</h2><h3 id="mov"><a href="#mov" class="headerlink" title="mov"></a>mov</h3><p>将某一寄存器的值复制到另一寄存器（只能用于寄存器与寄存器或者寄存器与常量之间传值，不能用于内存地址），如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov x1, x0    ; 将寄存器x0的值赋值给x1</span><br></pre></td></tr></table></figure>

<h3 id="str-amp-stur"><a href="#str-amp-stur" class="headerlink" title="str&amp;stur"></a>str&amp;stur</h3><p>存储指令，(store register) 将寄存器中的值写入到内存中。str和stur都是存储指令，区别在寻址的偏移量正负之分。如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str x0, [sp, #0x8]    ; 将寄存器 x0 中的值保存到栈内存 [sp + 0x8] 处 </span><br><span class="line">stur x0, [x29, #-0x8]    ; 将寄存器x0中的值保存到栈内存 [x29 - 0x8] 处</span><br></pre></td></tr></table></figure>

<h3 id="ldr-amp-ldur"><a href="#ldr-amp-ldur" class="headerlink" title="ldr&amp;ldur"></a>ldr&amp;ldur</h3><p>读取指令（load register）；将内存地址的值读取到寄存器中。ldr和ldur的区别与上述存储指令相同，ldr用于正偏移的地址运算，ldur用于负地址。如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ldr x0, [sp, #0x8]    ; 将栈地址sp+0x8的值读取到x0寄存器中</span><br><span class="line">ldur x0, [x29, #-0x8]    ; 将栈地址x29-0x8的值读取到x0寄存器中</span><br></pre></td></tr></table></figure>

<h3 id="stp"><a href="#stp" class="headerlink" title="stp"></a>stp</h3><p>入栈指令（<code>str</code> 的变种指令，可以同时操作两个寄存器），如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stp x29, x30, [sp, #0x10] 	; 将 x29, x30 的值存入 sp 偏移 16 个字节的位置 </span><br></pre></td></tr></table></figure>

<h3 id="ldp"><a href="#ldp" class="headerlink" title="ldp"></a>ldp</h3><p>出栈指令（<code>ldr</code> 的变种指令，可以同时操作两个寄存器），如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldp x29, x30, [sp, #0x10] 	; 将 sp 偏移 16 个字节的值取出来，存入寄存器 x29 和寄存器 x30 </span><br></pre></td></tr></table></figure>

<h3 id="adrp"><a href="#adrp" class="headerlink" title="adrp"></a>adrp</h3><p>用来定位数据段中的数据用, 因为 <em>aslr</em> 会导致代码及数据的地址随机化, 用 <em>adrp</em> 来根据 <em>pc</em> 做辅助定位</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adrp	x8, _OBJC_SELECTOR_REFERENCES_@PAGE    ;将&#x27;_OBJC_SELECTOR_REFERENCES_&#x27;所在section的起始地址保存到x8寄存器中</span><br><span class="line">ldr	x1, [x8, _OBJC_SELECTOR_REFERENCES_@PAGEOFF]    ; 加上偏移量做一个寻址操作，并将地址保存到x1寄存器中。</span><br></pre></td></tr></table></figure>

<h3 id="sub"><a href="#sub" class="headerlink" title="sub"></a>sub</h3><p>减法指令；将两寄存器的值相减 并将结果保存到指定寄存器中，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sub x0, x0, #0x8    ; x0 = x0 - 0x8</span><br></pre></td></tr></table></figure>

<h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><p>加法指定；如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add x0, x0, #0x1    ; x0 = x0 + 0x1</span><br></pre></td></tr></table></figure>

<h3 id="sdiv"><a href="#sdiv" class="headerlink" title="sdiv"></a>sdiv</h3><p>除法运算指令；如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdiv x0, x1, x2       ; x0 = x1 / x2</span><br></pre></td></tr></table></figure>

<h3 id="mul"><a href="#mul" class="headerlink" title="mul"></a>mul</h3><p>乘法运算指令；如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mul x0, x1, x2        ; x0 = x1 * x2</span><br></pre></td></tr></table></figure>

<h3 id="and"><a href="#and" class="headerlink" title="and"></a>and</h3><p>按位与。如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">and x0, x0, #0xf      ; x0 = x0 &amp; 0xf</span><br></pre></td></tr></table></figure>

<h3 id="orr"><a href="#orr" class="headerlink" title="orr"></a>orr</h3><p>按位或。如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">orr x0, x0, #0xf      ; x0 = x0 | 0xf</span><br></pre></td></tr></table></figure>

<h3 id="eor"><a href="#eor" class="headerlink" title="eor"></a>eor</h3><p>按位异或。如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eor x0, x0, #0xf      ; x0 = x0 ^ 0xf</span><br></pre></td></tr></table></figure>

<h3 id="LSL"><a href="#LSL" class="headerlink" title="LSL"></a>LSL</h3><p>逻辑左移</p>
<h3 id="LSR"><a href="#LSR" class="headerlink" title="LSR"></a>LSR</h3><p>逻辑右移</p>
<h3 id="ASR"><a href="#ASR" class="headerlink" title="ASR"></a>ASR</h3><p>算术右移</p>
<h3 id="ROR"><a href="#ROR" class="headerlink" title="ROR"></a>ROR</h3><p>循环右移</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cbz	w8, LBB11_2    ; 如果w8寄存器的值为0，则跳转到‘LBB11_2’处</span><br></pre></td></tr></table></figure>

<h3 id="cbnz"><a href="#cbnz" class="headerlink" title="cbnz"></a>cbnz</h3><p>和非 0 比较（Compare），如果结果非零（Non Zero）就转移（只能跳到后面的指令）;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cbnz	w8, LBB11_2    ; 如果w8寄存器的值不等于0则跳转到‘LBB11_2’label处。</span><br></pre></td></tr></table></figure>

<h3 id="subs"><a href="#subs" class="headerlink" title="subs"></a>subs</h3><p>比较指令；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subs x0, x1, x2    ; x0 = x1 - x2, 并设置 CPSR 寄存器的 C 标志位</span><br></pre></td></tr></table></figure>

<h3 id="cmp"><a href="#cmp" class="headerlink" title="cmp"></a>cmp</h3><p>比较指令，相当于 <code>subs</code>，影响程序状态寄存器<code>CPSR </code>;</p>
<h3 id="cset"><a href="#cset" class="headerlink" title="cset"></a>cset</h3><p>比较指令，满足条件，则并置 <code>1</code>，否则置 <code>0</code> ，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmp w8, #2        ; 将寄存器 w8 的值和常量 2 进行比较</span><br><span class="line">cset w8, gt       ; 如果是大于(grater than)，则将寄存器 w8 的值设置为 1，否则设置为 0</span><br></pre></td></tr></table></figure>

<h3 id="b"><a href="#b" class="headerlink" title="b"></a>b</h3><p>（branch）跳转到某地址（无返回）, 不会改变 <em>lr (x30)</em> 寄存器的值，只改变pc寄存的值；一般是本方法内的跳转，如 <code>while</code> 循环，<code>if else</code> 等 ，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b LBB0_1      ; 直接跳转到标签 ‘LLB0_1’ 处开始执行</span><br></pre></td></tr></table></figure>

<h4 id="b-le（条件码）"><a href="#b-le（条件码）" class="headerlink" title="b.le（条件码）"></a>b.le（条件码）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.le	LBB11_2     ; CPSR寄存器 C=0，则跳转‘LBB11_2’</span><br></pre></td></tr></table></figure>

<h3 id="br"><a href="#br" class="headerlink" title="br"></a>br</h3><p>功能同上b指令。不同的是跳转的地址由寄存器传递。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">br x8    ; x8寄存器的值作为跳转地址</span><br></pre></td></tr></table></figure>

<h3 id="bl"><a href="#bl" class="headerlink" title="bl"></a>bl</h3><p>call指令。跳转到某地址（有返回），先将下一指令地址（即函数返回地址）保存到寄存器 <em>lr</em> (x30)中，再进行跳转 ；一般用于不同方法直接的调用 ，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bl 0x100cfa754	; 先将下一指令地址（‘0x100cfa754’ 函数调用后的返回地址）保存到寄存器 ‘lr’ 中，然后再调用 ‘0x100cfa754’ 函数</span><br></pre></td></tr></table></figure>

<h3 id="blr"><a href="#blr" class="headerlink" title="blr"></a>blr</h3><p>跳转到 <code>某寄存器</code> (的值)指向的地址（有返回），先将下一指令地址（即函数返回地址）保存到寄存器  <em>lr</em> (x30)中，再进行跳转；与bl不同的是，bl指令的内容具体的地址，blr则是读取寄存器内的值。如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blr x20       ; 先将下一指令地址（‘x20’指向的函数调用后的返回地址）保存到寄存器 ‘lr’ 中，然后再调用 ‘x20’ 指向的函数</span><br></pre></td></tr></table></figure>

<h3 id="fcvtzs"><a href="#fcvtzs" class="headerlink" title="fcvtzs"></a>fcvtzs</h3><p>(Float Convert To Zero Signed)<em>浮点数</em> 转化为 <em>定点数</em> （舍入为0），如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fcvtzs w0, s0	    ; 将向量寄存器 s0 的值(浮点数，转换成 定点数)保存到寄存器 w0 中</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="cbz"><a href="#cbz" class="headerlink" title="cbz"></a>cbz</h3><p>和 0 比较（Compare），如果结果为零（Zero）就转移（只能跳到后面的指令）;</p>
<h3 id="ret"><a href="#ret" class="headerlink" title="ret"></a>ret</h3><p>子程序（函数调用）返回指令，返回地址已默认保存在寄存器 <em>lr</em> (x30) 中</p>
<h2 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h2><p>在汇编代码中常常会看到<code>LBB0_2:</code> ,这样的字样。<code>LBB0_2</code>称之为<code>local label</code>，在跳转中常常会用到</p>
<blockquote>
<p><code>LBB0_2</code>are local labels, which are normally used as branch destinations within a function.</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.ge	LBB11_2    ; CPSR的标志是ge时，pc寄存器置为LBB11_2处的地址</span><br></pre></td></tr></table></figure>



<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>ARM中的注释，如：</p>
<ol>
<li>“@”符号作为注释可以放在语句的开始处</li>
<li>“;”作为流程只能放在语句的末尾</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sub	sp, sp, #32                     ; =32</span><br></pre></td></tr></table></figure>



<h2 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h2><h3 id="数据定义伪操作"><a href="#数据定义伪操作" class="headerlink" title="数据定义伪操作"></a>数据定义伪操作</h3><p>数据定义伪操作一般用于为特定的数据分配内存单元，同时对该内存单元中的数据进行初始化，觉的数据定义伪操作有:</p>
<h4 id="byte"><a href="#byte" class="headerlink" title=".byte"></a>.byte</h4><p>在存储器中分配 一个字节的内存单元，用指定的数据对该存储单元进行初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.byte 0x1</span><br></pre></td></tr></table></figure>

<p>在当前地址分配一个字节的存储单元，将将其初始化为1，类似于C语言中的char _label &#x3D; 1.</p>
<h4 id="short"><a href="#short" class="headerlink" title=".short"></a>.short</h4><p>在存储器中分配2个字节的内存单元，并用指定的数据对该存储单元进行初始化，用于与.byte类似</p>
<h4 id="word"><a href="#word" class="headerlink" title=".word"></a>.word</h4><p>在存储器中分配4个字节的内存单元，并用指定的数据对该存储单元进行初始化，用于与.byte类似</p>
<h4 id="long"><a href="#long" class="headerlink" title=".long"></a>.long</h4><p>与.word的功能相同</p>
<h4 id="quad"><a href="#quad" class="headerlink" title=".quad"></a>.quad</h4><p>.quad的功能是在内存中分配8个字节的存储单元，并用指定的数据对该存储单元进行初始化。</p>
<h4 id="float"><a href="#float" class="headerlink" title=".float"></a>.float</h4><p>在存储器中分配4个字节的存储空间，并用指定的浮点数据对该空间进行初始化。</p>
<h4 id="space"><a href="#space" class="headerlink" title=".space"></a>.space</h4><p>.space伪操作用于分配一片连续的内存区域，并将其初始化为指定的值，如果后面的填充值省略不写，则默认在后面填充0</p>
<h4 id="skip"><a href="#skip" class="headerlink" title=".skip"></a>.skip</h4><p>等同与.space</p>
<h4 id="string-ascii-asciz"><a href="#string-ascii-asciz" class="headerlink" title=".string, ascii, .asciz"></a>.string, ascii, .asciz</h4><p>这3条伪操作的功能都是定义一个字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_label:</span><br><span class="line">.string &quot;Hello, World!&quot;</span><br></pre></td></tr></table></figure>

<h4 id="rept"><a href="#rept" class="headerlink" title=".rept"></a>.rept</h4><p>.rept伪操作功能是 重复执行后面的指令，以.rept开始，并以.endr结束，用法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.rept 3</span><br><span class="line">add r1, r1, #1</span><br><span class="line">.endr</span><br></pre></td></tr></table></figure>

<h3 id="杂项操作伪指令"><a href="#杂项操作伪指令" class="headerlink" title="杂项操作伪指令"></a>杂项操作伪指令</h3><p>GNU汇编中还有一些其他的伪操作，在汇编程序中经常会使用到它们，包括而在这些：</p>
<h4 id="align"><a href="#align" class="headerlink" title=".align"></a>.align</h4><p>.align伪操作可通过添加填充字节的试，使当前位置满足指定的对齐方式。举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.align 2</span><br><span class="line">.string &quot;abcde&quot;</span><br></pre></td></tr></table></figure>

<p>声明后面的字符串的对齐方式是4(2的2次方)字节对齐，这个字符串会占用8个字节的存储空间。</p>
<h4 id="section"><a href="#section" class="headerlink" title=".section"></a>.section</h4><p>.section伪操作用于定义一个段，一个GNU的源程序至少需要一个段，大的程序可以包含多个代码段和数据段。</p>
<p>可能用来定义自定义段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.section	__DATA,__const    ; 表示数据所在的segment和section</span><br></pre></td></tr></table></figure>

<h4 id="data"><a href="#data" class="headerlink" title=".data"></a>.data</h4><p>.data伪操作用来定义一个数据段</p>
<h4 id="text"><a href="#text" class="headerlink" title=".text"></a>.text</h4><p>.text伪操作用来定义一个数据段</p>
<h4 id="include"><a href="#include" class="headerlink" title=".include"></a>.include</h4><p>.include 伪操作用来包含一个头文件。</p>
<h4 id="extern"><a href="#extern" class="headerlink" title=".extern"></a>.extern</h4><p>.extern用于声明一个外部符号，即告诉编译器当前符号不是在本源文件中定义的，而是在其它源文件中定义的，当前文件需要引用这个符号。</p>
<h4 id="weak"><a href="#weak" class="headerlink" title=".weak"></a>.weak</h4><p>.weak用来声明一个符号是弱符号，即如果这个符号没有定义，编译器就会忽略，不会报错。</p>
<h4 id="end"><a href="#end" class="headerlink" title=".end"></a>.end</h4><p>.end代表程序的结束位置</p>
<h4 id="globl"><a href="#globl" class="headerlink" title=".globl"></a>.globl</h4><p><code>.globl	&quot;___block_descriptor_40_e8_32w_e5_v8?0l&quot;</code>表示一个全局的符号</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h4 id="栈对齐"><a href="#栈对齐" class="headerlink" title="栈对齐"></a>栈对齐</h4><p>虽然该函数没有临时变量，但是调用 printf 函数后，编译器自动会加上 该函数<em>返回值</em> 的处理，由于 <strong>arm64 规定了整数型返回值放在</strong> <strong>x0</strong> <strong>寄存器里</strong>，因此会隐藏有一个局部变量 int return_value; 的声明在，该临时变量占用 4字节空间；又因为 <strong>arm64 下对于使用</strong> <strong>sp</strong> <strong>作为地址基址寻址的时候，必须要</strong> <strong>16byte-alignment</strong>（对齐），所以申请了 16字节空间作为临时变量使用。具体参见 <a href="https://link.juejin.cn/?target=https://community.arm.com/developer/ip-products/processors/b/processors-ip-blog/posts/using-the-stack-in-aarch64-implementing-push-and-pop">这里</a>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903816362459144">arm64 架构之入栈&#x2F;出栈操作</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_32004383/article/details/114020564">汇编quad_ARM汇编</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/19/%E4%BB%8E%E6%B1%87%E7%BC%96%E7%9C%8BBlock%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E7%9A%84%E4%BA%A7%E7%94%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jin.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只代码狗的随笔">
      <meta itemprop="description" content="知其然知其所以然！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 一只代码狗的随笔">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/19/%E4%BB%8E%E6%B1%87%E7%BC%96%E7%9C%8BBlock%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E7%9A%84%E4%BA%A7%E7%94%9F/" class="post-title-link" itemprop="url">从汇编看Block底层</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-05-19 16:41:46" itemprop="dateCreated datePublished" datetime="2022-05-19T16:41:46+08:00">2022-05-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-05-23 13:58:56" itemprop="dateModified" datetime="2022-05-23T13:58:56+08:00">2022-05-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="block是什么"><a href="#block是什么" class="headerlink" title="block是什么"></a>block是什么</h1><p>源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)foo2 &#123;</span><br><span class="line">    self.myBlock = ^&#123;</span><br><span class="line">        [self foo];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Assemble后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&quot;-[Foo foo2]&quot;:                          ; @&quot;\01-[Foo foo2]&quot;</span><br><span class="line">Lfunc_begin4:</span><br><span class="line">; %bb.0:</span><br><span class="line">	sub	sp, sp, #96                     ; =96</span><br><span class="line">	stp	x29, x30, [sp, #80]             ; 16-byte Folded Spill</span><br><span class="line">	add	x29, sp, #80                    ; =80</span><br><span class="line">	stur	x0, [x29, #-8]</span><br><span class="line">	stur	x1, [x29, #-16]</span><br><span class="line">	add	x8, sp, #24                     ; =24</span><br><span class="line">	str	x8, [sp, #8]                    ; 8-byte Folded Spill</span><br><span class="line">Ltmp12:</span><br><span class="line">	adrp	x9, __NSConcreteStackBlock@GOTPAGE</span><br><span class="line">	ldr	x9, [x9, __NSConcreteStackBlock@GOTPAGEOFF]</span><br><span class="line">	str	x9, [sp, #24]</span><br><span class="line">	mov	w9, #-1040187392</span><br><span class="line">	str	w9, [sp, #32]</span><br><span class="line">	str	wzr, [sp, #36]</span><br><span class="line">	adrp	x9, &quot;___11-[Foo foo2]_block_invoke&quot;@PAGE</span><br><span class="line">	add	x9, x9, &quot;___11-[Foo foo2]_block_invoke&quot;@PAGEOFF</span><br><span class="line">	str	x9, [sp, #40]</span><br><span class="line">	adrp	x9, &quot;___block_descriptor_40_e8_32s_e5_v8?0l&quot;@PAGE</span><br><span class="line">	add	x9, x9, &quot;___block_descriptor_40_e8_32s_e5_v8?0l&quot;@PAGEOFF</span><br><span class="line">	str	x9, [sp, #48]</span><br><span class="line">	add	x8, x8, #32                     ; =32</span><br><span class="line">	str	x8, [sp, #16]                   ; 8-byte Folded Spill</span><br><span class="line">	ldur	x0, [x29, #-8]</span><br><span class="line">	bl	_objc_retain</span><br><span class="line">	ldr	x2, [sp, #8]                    ; 8-byte Folded Reload</span><br><span class="line">	str	x0, [sp, #56]</span><br><span class="line">	ldur	x0, [x29, #-8]</span><br><span class="line">	adrp	x8, _OBJC_SELECTOR_REFERENCES_.2@PAGE</span><br><span class="line">	ldr	x1, [x8, _OBJC_SELECTOR_REFERENCES_.2@PAGEOFF]</span><br><span class="line">	bl	_objc_msgSend</span><br><span class="line">	ldr	x0, [sp, #16]                   ; 8-byte Folded Reload</span><br><span class="line">	mov	x1, #0</span><br><span class="line">	bl	_objc_storeStrong</span><br><span class="line">	ldp	x29, x30, [sp, #80]             ; 16-byte Folded Reload</span><br><span class="line">	add	sp, sp, #96                     ; =96</span><br><span class="line">	ret</span><br><span class="line">Ltmp13:</span><br><span class="line">Lfunc_end4:</span><br><span class="line">                                        ; -- End function</span><br><span class="line">	.p2align	2                               ; -- Begin function __11-[Foo foo2]_block_invoke</span><br><span class="line">&quot;___11-[Foo foo2]_block_invoke&quot;:        ; @&quot;__11-[Foo foo2]_block_invoke&quot;</span><br><span class="line">Lfunc_begin5:</span><br><span class="line">; %bb.0:</span><br><span class="line">	sub	sp, sp, #32                     ; =32</span><br><span class="line">	stp	x29, x30, [sp, #16]             ; 16-byte Folded Spill</span><br><span class="line">	add	x29, sp, #16                    ; =16</span><br><span class="line">	str	x0, [sp, #8]</span><br><span class="line">	str	x0, [sp]</span><br><span class="line">Ltmp14:</span><br><span class="line">	ldr	x0, [x0, #32]</span><br><span class="line">	adrp	x8, _OBJC_SELECTOR_REFERENCES_@PAGE</span><br><span class="line">	ldr	x1, [x8, _OBJC_SELECTOR_REFERENCES_@PAGEOFF]</span><br><span class="line">	bl	_objc_msgSend</span><br><span class="line">Ltmp15:</span><br><span class="line">	ldp	x29, x30, [sp, #16]             ; 16-byte Folded Reload</span><br><span class="line">	add	sp, sp, #32                     ; =32</span><br><span class="line">	ret</span><br><span class="line">Ltmp16:</span><br><span class="line">Lfunc_end5:</span><br><span class="line">                                        ; -- End function</span><br></pre></td></tr></table></figure>

<p>这里假设起始sp&#x3D;0x60，方便后续计算。依次解释指令的执行过程和寄存器，栈的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sub	sp, sp, #96                     ; =96</span><br><span class="line">stp	x29, x30, [sp, #80]             ; 16-byte Folded Spill</span><br><span class="line">add	x29, sp, #80                    ; =80</span><br><span class="line">stur	x0, [x29, #-8]</span><br><span class="line">stur	x1, [x29, #-16]</span><br></pre></td></tr></table></figure>

<ol>
<li>sub指令；sp &#x3D; sp - 0x60 &#x3D;&gt; sp &#x3D; 0x00</li>
<li>store pair指令； x29, x30寄存器的值存到sp+0x50&#x3D;0x50的地址，x29，x30表示fp，lr寄存器。</li>
<li>add指令；fp &#x3D; sp + 0x50 &#x3D; 0x50</li>
<li>store指令；x0寄存器的值存到[x29, #-8]&#x3D;0x50-0x8&#x3D;0x48的地址。x0&#x3D;self</li>
<li>同上，x1存到0x40的地址。x1&#x3D;@selector(foo2)</li>
</ol>
<p>此时寄存器和栈的状态如下</p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>x0</td>
<td>self</td>
</tr>
<tr>
<td>x1</td>
<td>@selector(foo2)</td>
</tr>
<tr>
<td>fp</td>
<td>0x50</td>
</tr>
<tr>
<td>sp</td>
<td>0x00</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>栈地址</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>0x60</td>
<td>上个函数的lr</td>
</tr>
<tr>
<td>0x58</td>
<td>上个函数的fp</td>
</tr>
<tr>
<td>0x50</td>
<td>self</td>
</tr>
<tr>
<td>0x48</td>
<td>@selector(foo2)</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">	add	x8, sp, #24                     ; =24</span><br><span class="line">	str	x8, [sp, #8]                    ; 8-byte Folded Spill</span><br><span class="line">Ltmp12:</span><br><span class="line">	adrp	x9, __NSConcreteStackBlock@GOTPAGE</span><br><span class="line">	ldr	x9, [x9, __NSConcreteStackBlock@GOTPAGEOFF]</span><br><span class="line">	str	x9, [sp, #24]</span><br><span class="line">	mov	w9, #-1040187392</span><br><span class="line">	str	w9, [sp, #32]</span><br><span class="line">	str	wzr, [sp, #36]</span><br><span class="line">	adrp	x9, &quot;___11-[Foo foo2]_block_invoke&quot;@PAGE</span><br><span class="line">	add	x9, x9, &quot;___11-[Foo foo2]_block_invoke&quot;@PAGEOFF</span><br><span class="line">	str	x9, [sp, #40]</span><br><span class="line">	adrp	x9, &quot;___block_descriptor_40_e8_32s_e5_v8?0l&quot;@PAGE</span><br><span class="line">	add	x9, x9, &quot;___block_descriptor_40_e8_32s_e5_v8?0l&quot;@PAGEOFF</span><br><span class="line">	str	x9, [sp, #48]</span><br></pre></td></tr></table></figure>

<ol>
<li>x8 &#x3D; sp + 24 &#x3D; 0x18</li>
<li>x8寄存器的值存到0x08的地址（[sp, #8] &#x3D; 0x00 + 0x8）</li>
<li>adrp是针对aslr技术，获取偏移后的地址；将__NSConcreteStackBlock的isa读取到x9寄存器</li>
<li>将x9寄存器的值保存到地址0x18</li>
<li>w9（4字节）赋值#-1040187392</li>
<li>w9寄存器的值存到地址0x20</li>
<li>wzr（word zero register），地址0x24写入4字节的0。</li>
<li>同上，x9寄存器赋值”___11-[Foo foo2]_block_invoke”的地址</li>
<li>x9寄存器的值存到地址0x28</li>
<li>同上将”___block_descriptor_40_e8_32s_e5_v8?0l”的地址存到地址0x30</li>
</ol>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>x0</td>
<td>self</td>
</tr>
<tr>
<td>x1</td>
<td>@selector(foo2)</td>
</tr>
<tr>
<td>fp</td>
<td>0x50</td>
</tr>
<tr>
<td>sp</td>
<td>0x00</td>
</tr>
<tr>
<td>x8</td>
<td>0x18</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>栈地址</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>0x60</td>
<td>上个函数的lr</td>
</tr>
<tr>
<td>0x58</td>
<td>上个函数的fp</td>
</tr>
<tr>
<td>0x50</td>
<td>self</td>
</tr>
<tr>
<td>0x48</td>
<td>@selector(foo2)</td>
</tr>
<tr>
<td>…</td>
<td></td>
</tr>
<tr>
<td>0x30</td>
<td>“___block_descriptor_40_e8_32s_e5_v8?0l”</td>
</tr>
<tr>
<td>0x28</td>
<td>“___11-[Foo foo2]_block_invoke”</td>
</tr>
<tr>
<td>0x20</td>
<td>-1040187392; 0</td>
</tr>
<tr>
<td>0x18</td>
<td>__NSConcreteStackBlock</td>
</tr>
<tr>
<td>0x10</td>
<td></td>
</tr>
<tr>
<td>0x08</td>
<td>0x18</td>
</tr>
<tr>
<td>0x00</td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">add	x8, x8, #32                     ; =32</span><br><span class="line">str	x8, [sp, #16]                   ; 8-byte Folded Spill</span><br><span class="line">ldur	x0, [x29, #-8]</span><br><span class="line">bl	_objc_retain</span><br><span class="line">ldr	x2, [sp, #8]                    ; 8-byte Folded Reload</span><br><span class="line">str	x0, [sp, #56]</span><br><span class="line">ldur	x0, [x29, #-8]</span><br><span class="line">adrp	x8, _OBJC_SELECTOR_REFERENCES_.2@PAGE</span><br><span class="line">ldr	x1, [x8, _OBJC_SELECTOR_REFERENCES_.2@PAGEOFF]</span><br><span class="line">bl	_objc_msgSend</span><br><span class="line">ldr	x0, [sp, #16]                   ; 8-byte Folded Reload</span><br><span class="line">mov	x1, #0</span><br><span class="line">bl	_objc_storeStrong</span><br></pre></td></tr></table></figure>

<ol>
<li>x8 &#x3D; x8 + 0x20 &#x3D; 0x38</li>
<li>x8寄存器值存到地址0x10</li>
<li>x0 &#x3D; self</li>
<li>调用_objc_retain函数</li>
<li>x2 &#x3D; 0x18</li>
<li>x0寄存器值存到地址0x38</li>
<li><em>OBJC_SELECTOR_REFERENCES</em>.2指的是@selector(setMyBlock:)。x1 &#x3D; @selector(setMyBlock:)</li>
<li>调用_objc_msgSend函数</li>
<li>地址0x10的值读取到x0寄存器</li>
<li>x1 &#x3D; 0</li>
<li>调用_objc_storeStrong</li>
</ol>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>x0</td>
<td>self</td>
</tr>
<tr>
<td>x1</td>
<td>@selector(foo2)</td>
</tr>
<tr>
<td>fp</td>
<td>0x50</td>
</tr>
<tr>
<td>sp</td>
<td>0x00</td>
</tr>
<tr>
<td>x8</td>
<td>0x18</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>栈地址</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>0x60</td>
<td>上个函数的lr</td>
</tr>
<tr>
<td>0x58</td>
<td>上个函数的fp</td>
</tr>
<tr>
<td>0x50</td>
<td>self</td>
</tr>
<tr>
<td>0x48</td>
<td>@selector(foo2)</td>
</tr>
<tr>
<td>0x38</td>
<td>self</td>
</tr>
<tr>
<td>0x30</td>
<td>“___block_descriptor_40_e8_32s_e5_v8?0l”</td>
</tr>
<tr>
<td>0x28</td>
<td>“___11-[Foo foo2]_block_invoke”</td>
</tr>
<tr>
<td>0x20</td>
<td>-1040187392; 0</td>
</tr>
<tr>
<td>0x18</td>
<td>__NSConcreteStackBlock</td>
</tr>
<tr>
<td>0x10</td>
<td>0x38</td>
</tr>
<tr>
<td>0x08</td>
<td>0x18</td>
</tr>
<tr>
<td>0x00</td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ldp	x29, x30, [sp, #80]             ; 16-byte Folded Reload</span><br><span class="line">add	sp, sp, #96                     ; =96</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<ol>
<li>恢复上个函数的fp，lr寄存器值</li>
<li>sp -&#x3D; 0x60</li>
<li>return</li>
</ol>
<p>上述就是foo2函数的指令执行过程， 可以发现block初始化的时候是分配在栈空间，block也是个对象，有isa指正，这里是__NSConcreteStackBlock类。</p>
<p>通过<code>clang -rewrite-objc Foo.m</code>可以看到block结构体的声明，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BLOCK_IMPL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLOCK_IMPL</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__block_impl</span> &#123;</span><br><span class="line">  <span class="type">void</span> *isa;</span><br><span class="line">  <span class="type">int</span> Flags;</span><br><span class="line">  <span class="type">int</span> Reserved;</span><br><span class="line">  <span class="type">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__Foo__foo2_block_impl_0</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__block_impl</span> impl;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__Foo__foo2_block_desc_0</span>* Desc;</span><br><span class="line">  Foo *<span class="type">const</span> __strong self;</span><br><span class="line">  __Foo__foo2_block_impl_0(<span class="type">void</span> *fp, <span class="keyword">struct</span> __Foo__foo2_block_desc_0 *desc, Foo *<span class="type">const</span> __strong _self, <span class="type">int</span> flags=<span class="number">0</span>) : <span class="built_in">self</span>(_self) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>栈地址</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>0x38</td>
<td>self</td>
</tr>
<tr>
<td>0x30</td>
<td>“___block_descriptor_40_e8_32s_e5_v8?0l”</td>
</tr>
<tr>
<td>0x28</td>
<td>“___11-[Foo foo2]_block_invoke”</td>
</tr>
<tr>
<td>0x20</td>
<td>-1040187392; 0</td>
</tr>
<tr>
<td>0x18</td>
<td>__NSConcreteStackBlock</td>
</tr>
</tbody></table>
<p>跟栈去的内存分配完全吻合。从低地址到高地址依次为isa，Flags，Reserved，FuncPtr，Desc，self。其中self就是block捕获的变量。</p>
<p>接着看下block_descriptor到底是什么。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">	.private_extern	&quot;___block_descriptor_40_e8_32s_e5_v8?0l&quot; ; @&quot;__block_descriptor_40_e8_32s_e5_v8\01?0l&quot;</span><br><span class="line">	.section	__DATA,__const</span><br><span class="line">	.globl	&quot;___block_descriptor_40_e8_32s_e5_v8?0l&quot;</span><br><span class="line">	.weak_def_can_be_hidden	&quot;___block_descriptor_40_e8_32s_e5_v8?0l&quot;</span><br><span class="line">	.p2align	3</span><br><span class="line">&quot;___block_descriptor_40_e8_32s_e5_v8?0l&quot;:</span><br><span class="line">	.quad	0                               ; 0x0</span><br><span class="line">	.quad	40                              ; 0x28</span><br><span class="line">	.quad	___copy_helper_block_e8_32s</span><br><span class="line">	.quad	___destroy_helper_block_e8_32s</span><br><span class="line">	.quad	l_.str</span><br><span class="line">	.quad	256                             ; 0x100</span><br></pre></td></tr></table></figure>

<p>可以看到<code>___block_descriptor_40_e8_32s_e5_v8</code>在data段。</p>
<p>cpp的结构如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">__Foo__foo_block_desc_0</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> reserved;</span><br><span class="line">  <span class="type">size_t</span> Block_size;</span><br><span class="line">  <span class="built_in">void</span> (*copy)(<span class="keyword">struct</span> __Foo__foo_block_impl_0*, <span class="keyword">struct</span> __Foo__foo_block_impl_0*);</span><br><span class="line">  <span class="built_in">void</span> (*dispose)(<span class="keyword">struct</span> __Foo__foo_block_impl_0*);</span><br><span class="line">&#125; __Foo__foo_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> __Foo__foo_block_impl_0), __Foo__foo_block_copy_0, __Foo__foo_block_dispose_0&#125;;</span><br></pre></td></tr></table></figure>

<p>结合<code>__Foo__foo_block_desc_0</code>的结构，可以得到reserved&#x3D;0，Block_size&#x3D;40。跟上述栈的内存分配吻合。而后则是copy和destory函数。</p>
<h1 id="为什么会产生循环引用"><a href="#为什么会产生循环引用" class="headerlink" title="为什么会产生循环引用"></a>为什么会产生循环引用</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bl	_objc_retain 			; x0 = self</span><br></pre></td></tr></table></figure>

<p>上述汇编代码中可以看到在构建block时，self被调用retain。从而导致了循环引用的问题出现。</p>
<h1 id="weak是如何解除循环引用的？"><a href="#weak是如何解除循环引用的？" class="headerlink" title="__weak是如何解除循环引用的？"></a>__weak是如何解除循环引用的？</h1><p>接着上述代码加上weak修饰符，如下👇🏻。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)foo &#123;</span><br><span class="line">    __<span class="keyword">weak</span> Foo *wself = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">self</span>.myBlock = ^&#123;</span><br><span class="line">        [wself foo];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>assemble：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&quot;-[Foo foo]&quot;:                           ; @&quot;\01-[Foo foo]&quot;</span><br><span class="line">Lfunc_begin0:</span><br><span class="line">; %bb.0:</span><br><span class="line">	sub	sp, sp, #128                    ; =128</span><br><span class="line">	stp	x29, x30, [sp, #112]            ; 16-byte Folded Spill</span><br><span class="line">	add	x29, sp, #112                   ; =112</span><br><span class="line">	stur	x0, [x29, #-8]</span><br><span class="line">	stur	x1, [x29, #-16]</span><br><span class="line">Ltmp3:</span><br><span class="line">	ldur	x1, [x29, #-8]</span><br><span class="line">	sub	x0, x29, #24                    ; =24</span><br><span class="line">	str	x0, [sp, #8]                    ; 8-byte Folded Spill</span><br><span class="line">	bl	_objc_initWeak</span><br><span class="line">	ldr	x1, [sp, #8]                    ; 8-byte Folded Reload</span><br><span class="line">	add	x8, sp, #48                     ; =48</span><br><span class="line">	str	x8, [sp, #24]                   ; 8-byte Folded Spill</span><br><span class="line">	adrp	x9, __NSConcreteStackBlock@GOTPAGE</span><br><span class="line">	ldr	x9, [x9, __NSConcreteStackBlock@GOTPAGEOFF]</span><br><span class="line">	str	x9, [sp, #48]</span><br><span class="line">	mov	w9, #-1040187392</span><br><span class="line">	str	w9, [sp, #56]</span><br><span class="line">	str	wzr, [sp, #60]</span><br><span class="line">	adrp	x9, &quot;___10-[Foo foo]_block_invoke&quot;@PAGE</span><br><span class="line">	add	x9, x9, &quot;___10-[Foo foo]_block_invoke&quot;@PAGEOFF</span><br><span class="line">	str	x9, [sp, #64]</span><br><span class="line">	adrp	x9, &quot;___block_descriptor_40_e8_32w_e5_v8?0l&quot;@PAGE</span><br><span class="line">	add	x9, x9, &quot;___block_descriptor_40_e8_32w_e5_v8?0l&quot;@PAGEOFF</span><br><span class="line">	str	x9, [sp, #72]</span><br><span class="line">	add	x0, x8, #32                     ; =32</span><br><span class="line">	str	x0, [sp, #16]                   ; 8-byte Folded Spill</span><br><span class="line">	bl	_objc_copyWeak</span><br><span class="line">	ldr	x2, [sp, #24]                   ; 8-byte Folded Reload</span><br><span class="line">	ldur	x0, [x29, #-8]</span><br><span class="line">	adrp	x8, _OBJC_SELECTOR_REFERENCES_.2@PAGE</span><br><span class="line">	ldr	x1, [x8, _OBJC_SELECTOR_REFERENCES_.2@PAGEOFF]</span><br><span class="line">Ltmp0:</span><br><span class="line">	bl	_objc_msgSend</span><br><span class="line">Ltmp1:</span><br><span class="line">; %bb.1:</span><br><span class="line">	ldr	x0, [sp, #16]                   ; 8-byte Folded Reload</span><br><span class="line">	bl	_objc_destroyWeak</span><br><span class="line">	sub	x0, x29, #24                    ; =24</span><br><span class="line">	bl	_objc_destroyWeak</span><br><span class="line">	ldp	x29, x30, [sp, #112]            ; 16-byte Folded Reload</span><br><span class="line">	add	sp, sp, #128                    ; =128</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>

<p>从汇编中可以看到，在初始化wself的时候调用了objc_initWeak函数，在构建block结构的时候使用了objc_copyWeak。没有使用objc_retain，因此self的引用计数没有加1。从而没有循环引用的出现。</p>
<h1 id="block内为什么需要-strong呢？"><a href="#block内为什么需要-strong呢？" class="headerlink" title="block内为什么需要__strong呢？"></a>block内为什么需要__strong呢？</h1><p>看👇🏻代码，block中两次引用了wself。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)foo &#123;</span><br><span class="line">    __<span class="keyword">weak</span> Foo *wself = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">self</span>.myBlock = ^&#123;</span><br><span class="line">        [wself foo1];</span><br><span class="line">        [wself foo1];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>assemble:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&quot;___10-[Foo foo]_block_invoke&quot;:         ; @&quot;__10-[Foo foo]_block_invoke&quot;</span><br><span class="line">Lfunc_begin1:</span><br><span class="line">; %bb.0:</span><br><span class="line">	sub	sp, sp, #64                     ; =64</span><br><span class="line">	stp	x29, x30, [sp, #48]             ; 16-byte Folded Spill</span><br><span class="line">	add	x29, sp, #48                    ; =48</span><br><span class="line">	str	x0, [sp, #8]                    ; 8-byte Folded Spill</span><br><span class="line">	stur	x0, [x29, #-8]</span><br><span class="line">	stur	x0, [x29, #-16]</span><br><span class="line">Ltmp8:</span><br><span class="line">	add	x0, x0, #32                     ; =32</span><br><span class="line">	bl	_objc_loadWeakRetained</span><br><span class="line">	str	x0, [sp]                        ; 8-byte Folded Spill</span><br><span class="line">	adrp	x8, _OBJC_SELECTOR_REFERENCES_.2@PAGE</span><br><span class="line">	str	x8, [sp, #16]                   ; 8-byte Folded Spill</span><br><span class="line">	ldr	x1, [x8, _OBJC_SELECTOR_REFERENCES_.2@PAGEOFF]</span><br><span class="line">	bl	_objc_msgSend</span><br><span class="line">	ldr	x0, [sp]                        ; 8-byte Folded Reload</span><br><span class="line">	bl	_objc_release</span><br><span class="line">	ldr	x0, [sp, #8]                    ; 8-byte Folded Reload</span><br><span class="line">	add	x0, x0, #32                     ; =32</span><br><span class="line">	bl	_objc_loadWeakRetained</span><br><span class="line">	ldr	x8, [sp, #16]                   ; 8-byte Folded Reload</span><br><span class="line">	str	x0, [sp, #24]                   ; 8-byte Folded Spill</span><br><span class="line">	ldr	x1, [x8, _OBJC_SELECTOR_REFERENCES_.2@PAGEOFF]</span><br><span class="line">	bl	_objc_msgSend</span><br><span class="line">	ldr	x0, [sp, #24]                   ; 8-byte Folded Reload</span><br><span class="line">	bl	_objc_release</span><br><span class="line">Ltmp9:</span><br><span class="line">	ldp	x29, x30, [sp, #48]             ; 16-byte Folded Reload</span><br><span class="line">	add	sp, sp, #64                     ; =64</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bl	_objc_loadWeakRetained</span><br><span class="line">str	x0, [sp]                        ; 8-byte Folded Spill</span><br><span class="line">adrp	x8, _OBJC_SELECTOR_REFERENCES_.2@PAGE</span><br><span class="line">str	x8, [sp, #16]                   ; 8-byte Folded Spill</span><br><span class="line">ldr	x1, [x8, _OBJC_SELECTOR_REFERENCES_.2@PAGEOFF]</span><br><span class="line">bl	_objc_msgSend</span><br><span class="line">ldr	x0, [sp]                        ; 8-byte Folded Reload</span><br><span class="line">bl	_objc_release</span><br></pre></td></tr></table></figure>

<p>从这块片段可以看到在引用wself时，先调用了objc_loadWeakRetained，refcnt + 1。然后通过objc_msgSend调用了具体的方法，接着调用了objc_release，refcnt - 1。可以看到苹果底层在引用weak时还是比较严谨的。</p>
<p>可以看到在引用两次wself时，每次引用都会先调用objc_loadWeakRetained，紧接着调用objc_msgSend。在多线程的场景下，两次引用中间self存在被释放的情况，当self被释放后，wself就会被weak系统机制置为nil，从而导致在block的执行过程中self被释放，从而导致一些错误。</p>
<p>接着看一下使用strong修饰后的结果。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)foo &#123;</span><br><span class="line">    __<span class="keyword">weak</span> Foo *wself = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">self</span>.myBlock = ^&#123;</span><br><span class="line">        __<span class="keyword">strong</span> Foo *sself = wself;</span><br><span class="line">        [sself foo];</span><br><span class="line">        [sself foo];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>assemble:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&quot;___10-[Foo foo]_block_invoke&quot;:         ; @&quot;__10-[Foo foo]_block_invoke&quot;</span><br><span class="line">Lfunc_begin1:</span><br><span class="line">; %bb.0:</span><br><span class="line">	sub	sp, sp, #64                     ; =64</span><br><span class="line">	stp	x29, x30, [sp, #48]             ; 16-byte Folded Spill</span><br><span class="line">	add	x29, sp, #48                    ; =48</span><br><span class="line">	stur	x0, [x29, #-8]</span><br><span class="line">	stur	x0, [x29, #-16]</span><br><span class="line">Ltmp5:</span><br><span class="line">	add	x0, x0, #32                     ; =32</span><br><span class="line">	bl	_objc_loadWeakRetained</span><br><span class="line">	add	x8, sp, #24                     ; =24</span><br><span class="line">	str	x8, [sp, #16]                   ; 8-byte Folded Spill</span><br><span class="line">	str	x0, [sp, #24]</span><br><span class="line">	ldr	x0, [sp, #24]</span><br><span class="line">	adrp	x8, _OBJC_SELECTOR_REFERENCES_@PAGE</span><br><span class="line">	str	x8, [sp, #8]                    ; 8-byte Folded Spill</span><br><span class="line">	ldr	x1, [x8, _OBJC_SELECTOR_REFERENCES_@PAGEOFF]</span><br><span class="line">	bl	_objc_msgSend</span><br><span class="line">	ldr	x8, [sp, #8]                    ; 8-byte Folded Reload</span><br><span class="line">	ldr	x0, [sp, #24]</span><br><span class="line">	ldr	x1, [x8, _OBJC_SELECTOR_REFERENCES_@PAGEOFF]</span><br><span class="line">	bl	_objc_msgSend</span><br><span class="line">	ldr	x0, [sp, #16]                   ; 8-byte Folded Reload</span><br><span class="line">	mov	x1, #0</span><br><span class="line">Ltmp6:</span><br><span class="line">	bl	_objc_storeStrong</span><br><span class="line">	ldp	x29, x30, [sp, #48]             ; 16-byte Folded Reload</span><br><span class="line">	add	sp, sp, #64                     ; =64</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>

<p>在加上strong修饰后，因为后续代码中都在引用sself，所以sself在最后才通过objc_storeStrong(&amp;sself, nil)的方式进行一次release。从而也保证了在block调用过程中，self的refcnt一直是+1的状态，在block执行过程中不存在被提前释放的情况。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/12/Mach-O%E6%B7%B7%E6%B7%86%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jin.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只代码狗的随笔">
      <meta itemprop="description" content="知其然知其所以然！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 一只代码狗的随笔">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/12/Mach-O%E6%B7%B7%E6%B7%86%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Mach-O混淆原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-02-12 22:43:00" itemprop="dateCreated datePublished" datetime="2022-02-12T22:43:00+08:00">2022-02-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-06-15 16:32:04" itemprop="dateModified" datetime="2022-06-15T16:32:04+08:00">2022-06-15</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Mach-O混淆原理"><a href="#Mach-O混淆原理" class="headerlink" title="Mach-O混淆原理"></a>Mach-O混淆原理</h1><h2 id="混淆流程"><a href="#混淆流程" class="headerlink" title="混淆流程"></a>混淆流程</h2><h4 id="1-获取Mach-O"><a href="#1-获取Mach-O" class="headerlink" title="1. 获取Mach-O"></a>1. 获取Mach-O</h4><p>解压ipa包，获取到可执行文件即Mach-O文件。</p>
<h4 id="2-修改类名"><a href="#2-修改类名" class="headerlink" title="2. 修改类名"></a>2. 修改类名</h4><p>修改Mach-O文件中的__objc_classname section中的类名字符串为等长度的替换字符串; 为了保证使用NSClassFromString函数可以正确的获取到原始类，这里记录修改以前的字符映射关系后续使用。</p>
<h4 id="3-重签名"><a href="#3-重签名" class="headerlink" title="3. 重签名"></a>3. 重签名</h4><p>使用codesign，将ipa重签名</p>
<h2 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h2><p>这里拿最简单的一个例子做介绍，源码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;Animal.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;Man.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> foo(<span class="type">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        [[Man alloc] init];</span><br><span class="line">        </span><br><span class="line">        [[Animal alloc] init];</span><br><span class="line">        </span><br><span class="line">        foo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> foo() &#123;</span><br><span class="line">    Class cls = <span class="built_in">NSClassFromString</span>(<span class="string">@&quot;Man&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中声明了两个类Animal和Man。然后main文件中调用了两个类个构造方法。很简单是吧~</p>
<p>接下来，将项目打包，就可以获取到可执行文件了。</p>
<h3 id="类名的作用"><a href="#类名的作用" class="headerlink" title="类名的作用"></a>类名的作用</h3><p>想想程序运行中什么时候会用到类名？</p>
<p>程序在装载的时候构建了一个NXMapTable——<em>gdb_objc_realized_classes</em>，用于存放类，key是类名。runtime中objc_getClass函数就是从这个表中获取到对应名称的类。</p>
<p>那么代码<code> [[Man alloc] init];</code>到底执行了什么？</p>
<h2 id="Disassembly"><a href="#Disassembly" class="headerlink" title="Disassembly"></a>Disassembly</h2><p>使用hopper查看反编译后的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">0000000100003eaf         push       rbp</span><br><span class="line">0000000100003eb0         mov        rbp, rsp</span><br><span class="line">0000000100003eb3         push       r14</span><br><span class="line">0000000100003eb5         push       rbx</span><br><span class="line">0000000100003eb6         call       imp___stubs__objc_autoreleasePoolPush</span><br><span class="line">0000000100003ebb         mov        r14, rax</span><br><span class="line">0000000100003ebe         mov        rdi, qword [objc_cls_ref_Man]</span><br><span class="line">0000000100003ec5         call       imp___stubs__objc_alloc_init</span><br><span class="line">0000000100003eca         mov        rbx, qword [_objc_release_100004000]</span><br><span class="line">0000000100003ed1         mov        rdi, rax                                    ; argument &quot;instance&quot; for method _objc_release</span><br><span class="line">0000000100003ed4         call       rbx                                         ; _objc_release</span><br><span class="line">0000000100003ed6         mov        rdi, qword [objc_cls_ref_Animal]</span><br><span class="line">0000000100003edd         call       imp___stubs__objc_alloc_init</span><br><span class="line">0000000100003ee2         mov        rdi, rax                                    ; argument &quot;instance&quot; for method _objc_release</span><br><span class="line">0000000100003ee5         call       rbx                                         ; _objc_release</span><br><span class="line">0000000100003ee7         call       sub_100003efb</span><br><span class="line">0000000100003eec         mov        rdi, r14                                    ; argument &quot;pool&quot; for method imp___stubs__objc_autoreleasePoolPop</span><br><span class="line">0000000100003eef         call       imp___stubs__objc_autoreleasePoolPop</span><br><span class="line">0000000100003ef4         xor        eax, eax</span><br><span class="line">0000000100003ef6         pop        rbx</span><br><span class="line">0000000100003ef7         pop        r14</span><br><span class="line">0000000100003ef9         pop        rbp</span><br><span class="line">0000000100003efa         ret</span><br><span class="line">                        ; endp</span><br></pre></td></tr></table></figure>

<p>可以看到在使用<code>alloc] init]</code>创建一个Man对象的时候，<code>__objc_alloc_init</code>函数的入参是<code>objc_cls_ref_Man</code>——类的引用。同命令行使用MachOView看到的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100003ebe    movq 0x42f3(%rip), %rdi</span><br><span class="line">100003ec5    callq &quot;[0x100003f26-&gt;__objc_alloc_init]&quot;</span><br></pre></td></tr></table></figure>

<p>根据相对寻址得出rdi寄存器的内容为0x10003ec5 + 0x42f3 &#x3D; 0x100082b8。该地址的内容位于<code>__objc_classrefs</code> section, 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1000081b8 0x1000081f8</span><br></pre></td></tr></table></figure>

<p>指向的是<code>__objc_data</code> section，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">00000001000081d0         struct __objc_class &#123;                                  ; DATA XREF=__objc_class_Man_class</span><br><span class="line">                             _OBJC_METACLASS_$_NSObject,          // metaclass</span><br><span class="line">                             _OBJC_METACLASS_$_NSObject,          // superclass</span><br><span class="line">                             __objc_empty_cache,                  // cache</span><br><span class="line">                             0x0,                                 // vtable</span><br><span class="line">                             __objc_metaclass_Man_data            // data</span><br><span class="line">                         &#125;</span><br><span class="line">                             ; </span><br><span class="line">                             ; @class Man : NSObject &#123;</span><br><span class="line">                             ; &#125;</span><br><span class="line">                     __objc_class_Man_class:</span><br><span class="line">00000001000081f8         struct __objc_class &#123;                                  ; DATA XREF=0x100004030, objc_cls_ref_Man</span><br><span class="line">                             __objc_metaclass_Man_metaclass,      // metaclass</span><br><span class="line">                             _OBJC_CLASS_$_NSObject,              // superclass</span><br><span class="line">                             __objc_empty_cache,                  // cache</span><br><span class="line">                             0x0,                                 // vtable</span><br><span class="line">                             __objc_class_Man_data                // data</span><br><span class="line">                         &#125;</span><br><span class="line">                             ; </span><br><span class="line">                             ; @metaclass Animal  &#123;</span><br><span class="line">                             ; &#125;</span><br></pre></td></tr></table></figure>

<p>到这里已经是Man类本身了。由此可见，类的创建跟classname无关（旧版本的sdk编译的时候alloc，init也是通过objc_msgsend调用的）。</p>
<p>那么类名是什么时候被使用呢，然后在看下<code>__objc_class_Man_data</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> __objc_class_Man_data:</span><br><span class="line">0000000100008068         struct __objc_data &#123;                                   ; &quot;Man&quot;, DATA XREF=__objc_class_Man_class</span><br><span class="line">                             0x90,                                // flags</span><br><span class="line">                             8,                                   // instance start</span><br><span class="line">                             8,                                   // instance size</span><br><span class="line">                             0x0,</span><br><span class="line">                             0x0,                                 // ivar layout</span><br><span class="line">                             0x100003f70,                         // name</span><br><span class="line">                             0x0,                                 // base methods</span><br><span class="line">                             0x0,                                 // base protocols</span><br><span class="line">                             0x0,                                 // ivars</span><br><span class="line">                             0x0,                                 // weak ivar layout</span><br><span class="line">                             0x0                                  // base properties</span><br><span class="line">                         &#125;</span><br></pre></td></tr></table></figure>

<p>再看看name地址0x100003f70，该地址位于<code>__objc_classname</code> section。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100003f70 4d 61 6e 00 ... # Man.</span><br></pre></td></tr></table></figure>

<p>yes, name的地址的内容即为”Man”，寻找的类名。</p>
<h2 id="NSClassFromString"><a href="#NSClassFromString" class="headerlink" title="NSClassFromString"></a>NSClassFromString</h2><p>让我们再来看看NSClassFromString方式拿到的类的汇编：</p>
<p>Hopper:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">        ; ================ B E G I N N I N G   O F   P R O C E D U R E ================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                     sub_100003efb:</span><br><span class="line">0000000100003efb         push       rbp                                         ; CODE XREF=EntryPoint+56</span><br><span class="line">0000000100003efc         mov        rbp, rsp</span><br><span class="line">0000000100003eff         lea        rdi, qword [cfstring_Man]                   ; @&quot;Man&quot;, argument &quot;aClassName&quot; for method imp___stubs__NSClassFromString</span><br><span class="line">0000000100003f06         pop        rbp</span><br><span class="line">0000000100003f07         jmp        imp___stubs__NSClassFromString</span><br><span class="line">                        ; endp</span><br></pre></td></tr></table></figure>
<p>再看看cfstring_Man</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">        ; Section __cfstring</span><br><span class="line">        ; Range: [0x100004010; 0x100004030[ (32 bytes)</span><br><span class="line">        ; File offset : [16400; 16432[ (32 bytes)</span><br><span class="line">        ;   S_REGULAR</span><br><span class="line"></span><br><span class="line">                     cfstring_Man:</span><br><span class="line">0000000100004010         dq         ___CFConstantStringClassReference, 0x7c8, 0x100003f7b, 0x3 ; &quot;Man&quot;, DATA XREF=sub_100003efb+4</span><br><span class="line"></span><br><span class="line">  			; Section __cstring</span><br><span class="line">        ; Range: [0x100003f7b; 0x100003f7f[ (4 bytes)</span><br><span class="line">        ; File offset : [16251; 16255[ (4 bytes)</span><br><span class="line">        ; Flags: 0x2</span><br><span class="line">        ;   S_CSTRING_LITERALS</span><br><span class="line"></span><br><span class="line">0000000100003f7b         db         &quot;Man&quot;, 0                                    ; DATA XREF=cfstring_Man</span><br></pre></td></tr></table></figure>

<p>以上就不详细做寻址的步骤了，直接通过hopper可以看到，最终指向的<code>__cstring</code> section中的Man字符串。</p>
<p>由此可以看出”Man“指向不是<code>__objc_classname</code>，而是<code>__cstring</code>。因此修改了<code>__objc_classname</code>后会影响原代码中NSClassFromString获取类。</p>
<p>那么就会想到，把__cstring sectin中的类名也替换掉不就可以了吗？</p>
<p>答案是不可以，<code>__cstring</code> section包含的是文件中所有的字符串，为了避免<strong>非NSClassFromString</strong>函数调用同样字符串异常，不能直接修改这个section。平替方案是使用宏替换原有代码中NSClassFromString的调用，用原有类名映射出混淆后的类名，然后调用NSClassFromString函数。这样场景的还有一些runtime的函数。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Mach-O混淆是通过修改<code>__objc_classname</code>段来修改类名。在程序运行中类名只是个符号，用来映射类。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/28/%E4%BD%BF%E7%94%A8electron+vue%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jin.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只代码狗的随笔">
      <meta itemprop="description" content="知其然知其所以然！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 一只代码狗的随笔">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/04/28/%E4%BD%BF%E7%94%A8electron+vue%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/" class="post-title-link" itemprop="url">使用electron+vue搭建一个桌面应用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-04-28 00:00:00" itemprop="dateCreated datePublished" datetime="2020-04-28T00:00:00+08:00">2020-04-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>&amp;emsp;<a target="_blank" rel="noopener" href="https://electronjs.org/">electron</a> 是一个可以使用 web 技术来创建跨平台原生桌面应用的框架。借助 <a target="_blank" rel="noopener" href="https://electronjs.org/">electron</a> ，我们可以使用纯 JavaScript 来调用丰富的原生 APIs。优点：可以开发跨平台应用；成熟的社区；图形化的开发。缺点：应用体积过大；重型项目性能问题。</p>
<p>&amp;emsp;<a target="_blank" rel="noopener" href="https://electronjs.org/">electron</a> 核心的部分就是两个进程之间的协作——主进程和渲染进程。进程之间通过 ipcMain 和 ipcRenderer 来进行通信。
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/04/28/%E4%BD%BF%E7%94%A8electron+vue%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/12/Ivar%E5%92%8C%E7%B1%BB%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jin.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只代码狗的随笔">
      <meta itemprop="description" content="知其然知其所以然！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 一只代码狗的随笔">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/04/12/Ivar%E5%92%8C%E7%B1%BB%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/" class="post-title-link" itemprop="url">Ivar和类实例的内存分布</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-04-12 12:34:00" itemprop="dateCreated datePublished" datetime="2020-04-12T12:34:00+08:00">2020-04-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>​	ivar是类中的成员变量，@propery声明一个属性的时候就会产生一个成员变量。</p>
<h4 id="获取类的成员变量"><a href="#获取类的成员变量" class="headerlink" title="获取类的成员变量"></a>获取类的成员变量</h4><p>​	在runtime中，通过class_copyIvarList(Class cls, unsigned int * outCount)函数可以获取类的成员变量列表。在这里需要注意的是，class_copyIvarList函数获取的是当前类声明的成员变量，它的父类声明的 成员变量并不会返回。
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/04/12/Ivar%E5%92%8C%E7%B1%BB%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/04/iOS%E8%B6%85%E7%BA%A7%E7%AD%BE%E5%90%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jin.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只代码狗的随笔">
      <meta itemprop="description" content="知其然知其所以然！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 一只代码狗的随笔">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/04/04/iOS%E8%B6%85%E7%BA%A7%E7%AD%BE%E5%90%8D/" class="post-title-link" itemprop="url">iOS ipa超级签名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-04-04 20:34:00" itemprop="dateCreated datePublished" datetime="2020-04-04T20:34:00+08:00">2020-04-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>​	由于对外分外的adhoc包只能安装在provisioning profile中已添加的设备。因此当有新设备添加时，需要单独更新provisioning profile，并对包进行一次重签名。针对新设备包更新的问题，对超级签名的方案进行了调研。</p>
<h4 id="方案概述"><a href="#方案概述" class="headerlink" title="方案概述"></a>方案概述</h4><p>​	超级签名主要思路是让需要安装包的设备自行触发设备添加和重签名的操作，下图为超级签名的签名流程。
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/04/04/iOS%E8%B6%85%E7%BA%A7%E7%AD%BE%E5%90%8D/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/02/23/%E7%BB%99nil%E5%8F%91%E6%B6%88%E6%81%AF%E6%98%AF%E5%AE%89%E5%85%A8%E7%9A%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jin.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只代码狗的随笔">
      <meta itemprop="description" content="知其然知其所以然！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 一只代码狗的随笔">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/23/%E7%BB%99nil%E5%8F%91%E6%B6%88%E6%81%AF%E6%98%AF%E5%AE%89%E5%85%A8%E7%9A%84/" class="post-title-link" itemprop="url">从源码看对nil发消息是安全的</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-02-23 12:12:00" itemprop="dateCreated datePublished" datetime="2020-02-23T12:12:00+08:00">2020-02-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>​	在iOS开发中，我们会发现给nil发送消息时安全的，但是给null消息就会崩溃。这里探讨一下nil和null两者的区别。</p>
<p>​	打印nil和[NSNull null]的地址</p>
<blockquote>
<p>​	nil: 0x0</p>
<p>​	null: 0x10c054ff0</p>
</blockquote>
<p>​	当向两者发送消息时候，会调用msg_send函数进行方法的调用，msg_send函数的第一个参数调用者本身，这里为nil和null，第二个参数是SEL——方法的名称，而后跟着的是方法的参数。</p>
<blockquote>
<p>msg_send(nil, selector)</p>
<p>msg_sen(null, selector)</p>
</blockquote>
<p>​	接下来看msg_send源码的源码，因为参数及性能的问题，msg_send是用汇编写的，以下代码为msg_send起始和末尾片段。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">	ENTRY _objc_msgSend</span><br><span class="line">	UNWIND _objc_msgSend, NoFrame</span><br><span class="line"></span><br><span class="line">	cmp	p0, #0			// nil check and tagged pointer check</span><br><span class="line">#if SUPPORT_TAGGED_POINTERS</span><br><span class="line">	b.le	LNilOrTagged		//  (MSB tagged pointer looks negative)</span><br><span class="line">#else</span><br><span class="line">	b.eq	LReturnZero</span><br><span class="line">#endif</span><br><span class="line">	...</span><br><span class="line">	...</span><br><span class="line">LReturnZero:</span><br><span class="line">	// x0 is already zero</span><br><span class="line">	mov	x1, #0</span><br><span class="line">	movi	d0, #0</span><br><span class="line">	movi	d1, #0</span><br><span class="line">	movi	d2, #0</span><br><span class="line">	movi	d3, #0</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>

<p>​	汇编代码中第一个指令就是<code>cmp p0, #0</code>，比较第一个参数和数字0。从前面的打印结果可以看到nil的值为0x0，与0相等，然后调转到LReturnZero。LReturnZero中将寄存器的值还原为0，然后return回去。因此当给nil发消息时，不会崩溃，msg_send函数会返回0。再来看看null，因为null指针的值不是0，因此会继续走寻找方法的函数，然后null本身没有方法，因此最后抛出错误崩溃。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/01/22/C%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E5%90%AF%E5%8A%A8%E7%9A%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jin.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只代码狗的随笔">
      <meta itemprop="description" content="知其然知其所以然！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 一只代码狗的随笔">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/01/22/C%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E5%90%AF%E5%8A%A8%E7%9A%84/" class="post-title-link" itemprop="url">C语言可执行文件是如何启动的</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-01-22 23:11:00" itemprop="dateCreated datePublished" datetime="2020-01-22T23:11:00+08:00">2020-01-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>&amp;emsp;&amp;emsp;一个简单程序是如何启动的？简单来说，程序就是一个可执行文件，启动的过程分为以下三个部分：</p>
<blockquote>
<ol>
<li>执行fork函数，创建出一个新的进程并清理用户空间。</li>
<li>执行execve函数，加载器加载可执行文件。</li>
<li>执行地址跳转到ELF文件的入口地址，程序启动。</li>
</ol>
</blockquote>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/01/22/C%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E5%90%AF%E5%8A%A8%E7%9A%84/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jin.</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
